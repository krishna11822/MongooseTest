SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO

IF object_id('dbo.PartitionTableSp') IS NOT NULL
   DROP PROCEDURE dbo.PartitionTableSp
GO

/* $Header: ApplicationDB\Stored Procedures\PartitionTableSp.sp 10.1.0.1 03/30/2018 14:27:36 */
/*
***************************************************************
*                                                             *
*                           NOTICE                            *
*                                                             *
*   THIS SOFTWARE IS THE PROPERTY OF AND CONTAINS             *
*   CONFIDENTIAL INFORMATION OF INFOR AND/OR ITS AFFILIATES   *
*   OR SUBSIDIARIES AND SHALL NOT BE DISCLOSED WITHOUT PRIOR  *
*   WRITTEN PERMISSION. LICENSED CUSTOMERS MAY COPY AND       *
*   ADAPT THIS SOFTWARE FOR THEIR OWN USE IN ACCORDANCE WITH  *
*   THE TERMS OF THEIR SOFTWARE LICENSE AGREEMENT.            *
*   ALL OTHER RIGHTS RESERVED.                                *
*                                                             *
*   (c) COPYRIGHT 2018 INFOR.  ALL RIGHTS RESERVED.           *
*   THE WORD AND DESIGN MARKS SET FORTH HEREIN ARE            *
*   TRADEMARKS AND/OR REGISTERED TRADEMARKS OF INFOR          *
*   AND/OR ITS AFFILIATES AND SUBSIDIARIES. ALL RIGHTS        *
*   RESERVED.  ALL OTHER TRADEMARKS LISTED HEREIN ARE         *
*   THE PROPERTY OF THEIR RESPECTIVE OWNERS.                  *
*                                                             *
***************************************************************
*/


/* $Archive: /Tools/SQLScripts/ApplicationDB/Stored Procedures/PartitionTableSp.sp $
 *
 * Coredev 8 253084 DJohnson Thu May 16 2019
 * Problem with Include syntax
 *
 * CoreDev 7 252420 DJohnson Wed May 1 2019
 * Handle schema on object id.
 *
 * CoreDev 6 252299 DJohnson Mon Apr 15
 * Add included columns.
 *
 * CoreDev 5 248405 DJohnson Thu Oct 04
 * Add dbo. schema to path where missing.
 *
 * Core90310 4 RS8175 Mmarsolo Tue Oct 24 08:56:35 2017
 * RS8175 - Add missing join.
 *
 * Core90310 3 RS8175 Mmarsolo Mon Oct 23 10:48:41 2017
 * RS8175 - Filter constraints and indexes on schema passed into Sp.
 *
 * CoreDev 2 216047 Mmarsolo Tue Jul 19 10:02:15 2016
 * Remediate SQL Injection Risk for RC4 List
 * 216047 - SQL injection remediation, use QUOTENAME and REPLACE.
 *
 * SL8.04 1 RS4615 bbopp Tue Mar 26 08:23:10 2013
 * RS4615
 * Initial Version.
 *
 * $NoKeywords: $
 */
CREATE PROCEDURE [dbo].[PartitionTableSp]
   @PTableName TableNameType,
   @PDatabaseSchema ObjectNameType,
   @PSitePartitionScheme NVARCHAR(11),
   @PSitePartitioningColumn ColumnNameType,
   @Infobar InfobarType OUTPUT
AS
-- Check for existence of Generic External Touch Point routine (this section was generated by SpETPCodeSp and inserted by CallETPs.exe):
IF OBJECT_ID(N'dbo.EXTGEN_PartitionTableSp') IS NOT NULL
BEGIN
   DECLARE @EXTGEN_SpName sysname
   SET @EXTGEN_SpName = N'dbo.EXTGEN_PartitionTableSp'
   -- Invoke the ETP routine, passing in (and out) this routine's parameters:
   DECLARE @EXTGEN_Severity int 
   EXEC @EXTGEN_Severity = @EXTGEN_SpName 
      @PTableName
    , @PDatabaseSchema
    , @pSitePartitionScheme
    , @PSitePartitioningColumn
    , @Infobar OUTPUT
     
 -- ETP routine can RETURN 1 to signal that the remainder of this standard routine should now proceed: 
   IF @EXTGEN_Severity <> 1 
      RETURN @EXTGEN_Severity 
END 
-- End of Generic External Touch Point code. 

declare
   @Indexes table (
      IdxType NVARCHAR(11)  NOT NULL,
      IdxName SYSNAME       NOT NULL,
      IdxClustered        ListYesNoType,
      IdxString			  LongListType
   )
declare
   @SQLText    NVARCHAR(max),
   @ConsName   SYSNAME,
   @ConsString LongListType,
   @ConsType   NVARCHAR(11),
   @TableID    INT

   SET @TableID = OBJECT_ID(@PDatabaseSchema + N'.' + @PTableName)
-------------------------------------------------------------------------------
--  1. Capture primary and unique constraints and all indexes for @PTableName
-------------------------------------------------------------------------------
-- Primary and Unique constraints
insert into @Indexes (
   IdxType,
   IdxName,
   IdxClustered,
   IdxString)
select CONSTRAINT_TYPE,
      CONSTRAINT_NAME,
      case when si.indid = 1 then 1 else 0 end,
      N'(' + dbo.IndexKeyString(si.name,@PDatabaseSchema + N'.' + @PTableName) + N')'
   + CASE
    WHEN EXISTS (SELECT 1 FROM sys.index_columns sic
                        WHERE sic.object_id = @TableID
                          AND sic.index_id  = si.indid
                          AND sic.is_included_column = 1)
        THEN N' INCLUDE (' + dbo.IndexIncludeColumnString(si.name,@PDatabaseSchema + N'.' + @PTableName) + N')' -- Maybe this will be allowed some day.
        ELSE ''
     END
from INFORMATION_SCHEMA.TABLE_CONSTRAINTS as ISTC
inner JOIN sysindexes as si
   on si.id = @TableID
  and si.name = ISTC.CONSTRAINT_NAME
where ISTC.TABLE_SCHEMA = @PDatabaseSchema
  and ISTC.TABLE_NAME   = @PTableName
  and ISTC.CONSTRAINT_TYPE in (N'PRIMARY KEY',N'UNIQUE')


-- Indexes
insert into @Indexes (
   IdxType,
   IdxName,
   IdxClustered,
   IdxString)
select
   'INDEX',
   si.name,
   case when si.indid = 1 then 1 else 0 end,
   N'(' + dbo.IndexKeyString(si.name,@PDatabaseSchema + N'.' + @PTableName) + N')'
   + CASE
    WHEN EXISTS (SELECT 1 FROM sys.index_columns sic
                        WHERE sic.object_id = @TableID
                          AND sic.index_id  = si.indid
                          AND sic.is_included_column = 1)
        THEN N' INCLUDE (' + dbo.IndexIncludeColumnString(si.name,@PDatabaseSchema + N'.' + @PTableName) + N')'
        ELSE ''
     END
from sysindexes as si
inner join sys.objects so on so.object_id = si.id
where si.id = @TableID
  and SCHEMA_NAME(so.schema_id) = @PDatabaseSchema
  and si.status & 64 = 0 -- Ignores statistics
  and si.indid > 0 -- If no clustered indexes, table itself must be ignored.
  and si.indid <> 255 -- table contains ntext columns
  and not exists (
     select 1
     from sysconstraints as sc
     where si.id = sc.id
       and OBJECT_NAME(sc.constid) = si.name)


-------------------------------------------------------------------------------
--  2. Drop all primary and unique constraints and indexes for @PTableName
-------------------------------------------------------------------------------

set @SQLText = NULL
select @SQLText = COALESCE(@SQLText + N' ', N'') + N'ALTER TABLE '
   + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName) + N' DROP CONSTRAINT '
   + QUOTENAME(IdxName)
from @Indexes where IdxType <> 'INDEX'

select @SQLText = COALESCE(@SQLText + N' ', N'') + N' DROP INDEX '
   + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName) + N'.' + QUOTENAME(IdxName)
from @Indexes where IdxType = 'INDEX'

exec sys.sp_executesql @SQLText


-------------------------------------------------------------------------------
--  3. Add clustered constraint/index using PSitePartitionScheme for @PTableName
-------------------------------------------------------------------------------

set @SQLText = NULL
select @ConsName = IdxName,
       @ConsString = IdxString,
       @ConsType = IdxType
from @Indexes where IdxClustered = 1

if @ConsType = 'PRIMARY KEY'
begin
   select @SQLText = N'ALTER TABLE ' + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName)
      + N' ADD CONSTRAINT ' + QUOTENAME(@ConsName) + N' PRIMARY KEY CLUSTERED ' + 
      REPLACE(@ConsString,N'''',N'''''') + N' WITH FILLFACTOR = 90 ON ' + QUOTENAME(@PSitePartitionScheme)
      + N'(' + QUOTENAME(@PSitePartitioningColumn) + N')'
   exec sys.sp_executesql @SQLText
end
else if @ConsType = 'UNIQUE'
begin
   select @SQLText = N'ALTER TABLE ' + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName)
      + N' ADD CONSTRAINT ' + QUOTENAME(@ConsName) + N' UNIQUE CLUSTERED ' +
      REPLACE(@ConsString,N'''',N'''''') + N' WITH FILLFACTOR = 90 ON ' + QUOTENAME(@PSitePartitionScheme) 
      + N'(' + QUOTENAME(@PSitePartitioningColumn) + N')'
   exec sys.sp_executesql @SQLText
end
else if @ConsType = 'INDEX'
begin
   select @SQLText = N'CREATE CLUSTERED INDEX ' + QUOTENAME(@ConsName) + N' ON ' + 
   QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName) + N' ' + REPLACE(@ConsString,N'''',N'''''')
   + N' WITH FILLFACTOR = 90 ON ' + QUOTENAME(@PSitePartitionScheme) 
      + N'(' + QUOTENAME(@PSitePartitioningColumn) + N')'
   exec sys.sp_executesql @SQLText
end



-------------------------------------------------------------------------------
--  4. Add the rest of the non-clustered constraints and indexes for @PTableName
-------------------------------------------------------------------------------

set @SQLText = NULL
select @ConsName = IdxName,
       @ConsString = IdxString
from @Indexes where IdxClustered = 0 and IdxType = 'PRIMARY KEY'
if @@ROWCOUNT <> 0
   set @SQLText = N'ALTER TABLE ' + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName)
      + N' ADD CONSTRAINT ' + QUOTENAME(@ConsName) + N' PRIMARY KEY NONCLUSTERED ' +
      REPLACE(@ConsString,N'''',N'''''') + N'  WITH FILLFACTOR = 90'

select @SQLText = COALESCE(@SQLText + N' ', N'') + N' ALTER TABLE '
   + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName) + N' ADD CONSTRAINT '
   + QUOTENAME(IdxName) + N' UNIQUE NONCLUSTERED ' + REPLACE(IdxString,N'''',N'''''') + N' WITH FILLFACTOR = 90'
from @Indexes where IdxType = 'UNIQUE' and IdxClustered = 0

select @SQLText = COALESCE(@SQLText + N' ', N'') + N' CREATE INDEX '
   + QUOTENAME(IdxName) + N' ON ' + QUOTENAME(@PDatabaseSchema) + N'.' + QUOTENAME(@PTableName) + N' '
   + REPLACE(IdxString,N'''',N'''''') + N' WITH FILLFACTOR = 90'
from @Indexes where IdxType = 'INDEX' and IdxClustered = 0

exec sys.sp_executesql @SQLText

RETURN 0
GO

